#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "stack.h"
#include "ial.h"
#include "types.h"
#include "vnitrni.h"
#include "parser.h"

#define true 1
#define false 0



extern TAC *paska;                  //z vnitrni.c
extern T_ST_Vars *symbolTable;      //obe tabulky z parser.c
extern T_ST_Funcs *functionTable;

/*  toto je, zdá se k ničemu
T_ST_Vars *FindVar(char *name, tStack *tree_stack)
{
    tStackItem position=*tree_stack.top
    T_ST_Vars *table = position.data;     //ukazatel na strom, který se bude vracet
    while( table=findVarST( name, table)==NULL)
        {*position=*position.prev;
         table = position.data;
         if(stack.top==stack.bottom)
            return NULL;
        }
    return table;
}
*/

int interpret()
{
    TAC Instr;          //Instrukce
    int i = 0;          //index/pozice na pasce
    double op1, op2;      //tohle se bude posilat do arithmetic()
    int op1_typ, op2_typ;   //typy operandu
    T_ST_Vars *aux, *res;        //pomocny uzel a uzel pro vysledek
    T_ST_Funcs *funkce;        //pomocna promenna na uchovani dat o funkci
    TRetValue *RetValue;                //prvek zasobniku pro navraty
    tStack *returnStack = SInit();      //zasobnik navratovach hodnot
    tStack *tableStack = SInit();         //zasobnik tabulek symbolu
    tStack *funcStack = SInit();         //zasobnik s funkcemi a parametry pro volani
    tStack StackHelpItem;             //pomocny prvekpro zasobniky
    Tparam *param;           //struktura pro parametry
    T_Token pom1; pom2, pom3;   //pomocné tokeny
    
  
   //kontrolovat jenom typovost proměnných!!
    //Instr.type je bud promenna nebo prima hodnota
    

    while(1)
    {   
        Instr = paska[i++];         //nacitame z pasky a posouvame se po ni
        switch (Instr->operaror){
            case  FUNCTION: //tady nevim, co se ma delat, asi nic
                            break;
            case  RETURN:
                StackHelpItem = pop_top(tableStack);   //odebere z vrcholu zasobniku jednu tabulku funkci
                StackHelpItem = pop_top(returnStack); //odebere hodnotu z vrcholu zasobniku
                i= StackHelpItem->data->adress;       //nastavi vykonavani nasledujici instrukce
                *(StackHelpItem->data->returadress) = Instr->operand1; 
                        
                            break;
            case S_PLUS:
			case S_MINUS:
                if(Instr->operand1.type == S_ID) { //operand1 je to promenna
                    aux = findVarST(Instr->operand1->value, symbolTable);    //vyhledam ji v tabulce symbolu a ulozim si odkaz
					op1_typ = aux->data.type;
                    if(op1_typ == S_INT ) op1 = *((int)aux->data->value);
					else if (op1_typ == S_DOUB) op1 = *((double)aux->data->value);
					else return SEM_TYPE_ERROR;  //typ promenne  neni int ani double
                }
                else {     //operand1 neni promenna
					op1_typ = Instr->operand1->type;
                    if(op1_typ == S_INT ) op1 = *((int)aux->data->value);
					else if (op1_typ == S_DOUB) op1 = *((double)aux->data->value);
					else return SEM_TYPE_ERROR;  //typ promenne  neni int ani double
                }
				
                if(Instr->operand2.type == S_ID) { //operand2 je to promenna
                    aux = findVarST(Instr->operand2->value, symbolTable);    //vyhledam ji v tabulce symbolu a ulozim si odkaz
					op2_typ = aux->data.type;
                    if(op2_typ == S_INT ) op2 = *((int)aux->data->value);
					else if (op2_typ == S_DOUB) op2 = *((double)aux->data->value);
					else return SEM_TYPE_ERROR;  //typ promenne  neni int ani double
                }
                else {      //operand2 neni promenna
					op2_typ = Instr->operand1->type;
                    if(op2_typ == S_INT ) op2 = *((int)aux->data->value);
					else if (op2_typ == S_DOUB) op2 = *((double)aux->data->value);
					else return SEM_TYPE_ERROR;  //typ promenne  neni int ani double
                }
				
				res = findVarST(Instr->vysledek->value, symbolTable);
				if (res->data->value != NULL) free(res->data->value);
				
                //vypocet
                if(op1_typ == S_DOUB || op2_typ == S_DOUB) {
					res->data->value = (double*)malloc(sizeof(double));
					if(Instr->operaror == S_PLUS) *(res->data->value) = op1 + op2;
					else *(res->data->value) = op1 - op2;
					res->data->type = S_DOUB;
				}
                else {
					res->data->value = (int*)malloc(sizeof(int));
					if(Instr->operaror == S_PLUS) *(res->data->value) = op1 + op2;
					else *(res->data->value) = op1 - op2;
					res->data->type = S_INT;
				}

                break;
                 
            case S_MUL:
            case S_DIV:
                 if(Instr->operand1.type == S_ID) { //operand1 je to promenna
                    aux = findVarST(Instr->operand1->value, symbolTable);    //vyhledam ji v tabulce symbolu a ulozim si odkaz
					op1_typ = aux->data.type;
                    if(op1_typ != S_INT || op1_typ != S_DOUB ) return SEM_TYPE_ERROR; 
					else op1 = *((double)aux->data->value);
					
                }
                else {      //operand1 neni promenna                    
					op1 = *((double)aux->data->value);					
                }
				
                if(Instr->operand1.type == S_ID) { //operand2 je to promenna
                    aux = findVarST(Instr->operand1->value, symbolTable);    //vyhledam ji v tabulce symbolu a ulozim si odkaz
					op2_typ = aux->data.type;
                    if(op2_typ != S_INT || op2_typ != S_DOUB ) return SEM_TYPE_ERROR; 
					else op2 = *((double)aux->data->value);
					
                }
                else {      //operand2 neni promenna                    
					op2 = *((double)aux->data->value);					
                }
				
				res = findVarST(Instr->vysledek->value, symbolTable);
				if (res->data->value != NULL) free(res->data->value);
				
                //vypocet
               	res->data->value = (double*)malloc(sizeof(double));
				if(Instr->operaror == S_MUL) *(res->data->value) = op1 * op2;
				else *(res->data->value) = op1 / op2;
				res->data->type = S_DOUB;
				
                break;
				
            case S_IS:	    assigment(FindVar(Instr->operand1), FindVar(Instr->vysledek));
                                break;   
                                
                                
                                                             
            case S_FUNC:    //volani funkce get_string
                            if(Instr->operand1->value=="get_string");
                                {if(param=malloc(sizeof(Tparam))==NULL)
                                    return INTERNAL_ERROR;
                                 param->free = 0;
                                 param->funkce->name="get_string";
                                 param->paramCount=0;
                                 garbage_add(array,&garbage_default_erase);
                                 if (push(funcStack, param)==INTERNAL_ERROR) //prida na vrchol zasobniku pole s parametry
                                     return INTERNAL_ERROR;
                                 break;
                                }
                            
                                
                                
                                
                           if(Instr->operand1->value=="put_string")
                                {if(param = malloc(sizeof(Tparam))==0)
                                    return INTERNAL_ERROR;
                                 param->free = -1;               //oznaceni teto funkce (pak se nemusi porovnavat nazvy)
                                 param->funkce->paramCount=0;   
                                 param->funkce->name="put_string";   
                                 garbage_add(param,&garbage_default_erase);
                                 if (push(funcStack, param)==INTERNAL_ERROR)
                                    return INTERNAL_ERROR;
                                 break;
                                }
                                
                            if(Instr->operand1->value=="strlen")
                                {if(param = malloc(sizeof(Tparam))==0)
                                    return INTERNAL_ERROR;
                                 param->free = 1;
                                 param->funkce->paramCount=1;
                                 param->funkce->name="strlen";
                                 garbage_add(param,&garbage_default_erase);
                                 if (push(funcStack, param)==INTERNAL_ERROR)
                                    return INTERNAL_ERROR;
                                 break;
                                }
                            
                            if(Instr->operand1->value=="get_substring")
                               {if(param = malloc(sizeof(Tparam))==0)
                                    return INTERNAL_ERROR;
                                 param->free = 3;
                                 param->funkce->name="get_substring";
                                 param->funkce->paramCount=3;
                                 garbage_add(param,&garbage_default_erase);
                                 if (push(funcStack, param)==INTERNAL_ERROR)
                                    return INTERNAL_ERROR;
                                 break;
                                }
                                                        
                            if(Instr->operand1->value=="find_string")
                               {if(param = malloc(sizeof(Tparam))==0)
                                    return INTERNAL_ERROR;
                                 param->free = 2;
                                 param->funkce->name="find_string";
                                 param->funkce->paramCount=2;
                                 garbage_add(param,&garbage_default_erase);
                                 if (push(funcStack, param)==INTERNAL_ERROR)
                                    return INTERNAL_ERROR;
                                 break;
                                }
                               
                           if(Instr->operand1->value=="sort_string")
                               {if(param = malloc(sizeof(Tparam))==0)
                                    return INTERNAL_ERROR;
                                 param->free = 1;
                                 param->funkce->name="sort_string";
                                 param->funkce->paramCount=1;
                                 garbage_add(param,&garbage_default_erase);
                                 if (push(funcStack, param)==INTERNAL_ERROR)
                                    return ERROR_INTER;
                                 break;
                                }
    
                             if(param = malloc(sizeof(Tparam))==0)
                                return INTERNAL_ERROR;
                             param->free = Instr;
                             param->funkce=Instr->operand1;
                             param->funkce->paramCount=Instr->operand1->paramCount;
                             garbage_add(param,&garbage_default_erase);
                             if (push(funcStack, param)==INTERNAL_ERROR)
                                return ERROR_INTER;
                             RetValue->returadress = Instr->vysledek
                            if(push(returnStack, RetValue)==INTERNAL_ERROR)
                                return ERROR_INTER;
                             break;
                                }
                                
                            //volani ostatnich funkci
                            
                                
             case S_GRT:
                            někamtypu bool=greater(FindVar(Instr->operand1), FindVar(Instr->operand2));
                                break;
            case S_LEQ:
                            někamtypu bool=leq(FindVar(Instr->operand1),FindVar(Instr->operand2), FindVar(Instr->vysledek));
                                break;
            case S_GEQ:
                            někam=geq(FindVar(Instr->operand1), FindVar(Instr->operand2), FindVar(Instr->vysledek) );
                                break;
            case S_EQ:
                            někam=eq(FindVar(Instr->operand1), FindVar(Instr->operand2), FindVar(Instr->vysledek));
                                break;
            case S_NEQ:
                            někam = neq(FindVar(Instr->operand1), FindVar(Instr->operand2), FindVar(Instr->vysledek));
                                break;
           
           
           
            case CALL:  //zjisti, kterou funkci volam azkontroluj jeji parametry
                        
                            if(funcStack->top->data->funkce->name == "get_string")
                                {Instr->vysledek->value=get_string();
                                 break;
                                }
                                
                            if(funcStack->top->data->funkce->name == "put_string")
                                break;
                                
                            if(funcStack->top->data->funkce->name == "strlen")
                                {
                                 if(funcStack->top->data->free == 0)
                                    StackHelpItem = funcStack->top->data->paramstack->top;
                                    if(StackHelpItem->data->paramstack->top->data->type==S_STR)
                                        Instr->vysledek->value=strlen(StackHelpItem->data->paramstack->top->data->value);
                                    else return 13;
                                 break;
                                }
                            
                       
                         if(funcStack->top->data->funkce->name == "find_string")
                            {
                             if(funcStack->top->data->free == 0)
                                {StackHelpItem = funcStack->top->data->paramstack->top;
                                 pom1 = (pop_back(&StackHelpItem)->data);
                                 pom2 = (pop_back(&StackHelpItem)->data);
                                 pom3 = (pop_back(&StackHelpItem)->data);
                                 if(pom1->type== S_STR && pom2->type==S_INT && pom3->type==S_INT)
                                     Instr->vysledek->value=strlen(StackHelpItem->data->paramstack->top->data->value);
                                 else return 13;        //ostatni
                                }
                             else return 4;      //chybi parametr
                             break;
                            }
                        
                            if(funcStack->top->data->funkce->name == "sort_string")
                            {
                             if(funcStack->top->data->free == 0)
                                {StackHelpItem = funcStack->top->data->paramstack->top;
                                 pom1 = (pop_back(&StackHelpItem)->data);
                                 if(pom1->type== S_STR)
                                     Instr->vysledek->value=sort_string(StackHelpItem->data->paramstack->top->data->value);
                                 else return 13;        //ostatni
                                }
                             else return 4;      //chybi parametr
                             break;
                            }
                           
                                //kontrola poctu parametru
                             if(funcStack->top->data->free != 0)
                                return 4;
                            
                             //kopíruji tabulku symbolu
                           if( push(tableStack, copyTable(tableStack->top))==INTERNAL_ERROR) //prida na vrchol zasobniku novou tabulku
                                return ERROR_INTER;
                                
                                //pepisu v ni hodnoty parametru
                            for(int j=funcStack->top->data->funkce->paramCount; j>0; j--)
                                {
                                    pom1 = pop_top(funcStack->top->data->paramStack); 
                                    aux = findVarST( pom1->name, tableStack->top->data);
                                    aux->data->value = pom1->value;
                                }
                            returnStack->top->data->adress = i;
                            dalsi i = (Instr->operand1-1);   //operand1 je dalsi instrukce, ale na zacatku cyklu se i inkrementuje
                                                             //proto -1

                                break;
                                
                                
                                
            case STORE_PARAM:
                                switch (funcStack->top->data->free){
                                    case -1: if(Instr->operand1->type==S_STR)       //tisknou se parametry funkce put_string()
                                                printf(Instr->operand1->value);
                                             else return 13;
                                                break;
                                    
                                    case 0: break;      //pole s parametry je plne, prebytecne se zahazuji
                                    
                                    default:
                                            if(push(funcStack->top->data->paramStack, Instr->operand1)==INTERNAL_ERROR)
                                                return INTERNAL_ERROR;
                                            funcStack->top->data->free--;       //snizeni hodnoty pocitadla volnych mist pro parametry
                                            break;
                                break;
                                }
                                        
                                break;
            case JMP:
                                i = operand1.type;      //zmeni se index na pasce
                                break;
            case JMP_NOT:
                                if(!boolval(Instr->operand1->value))
                                    i = operand1.type;
                                break;
        }
    }

    return 0;
}
